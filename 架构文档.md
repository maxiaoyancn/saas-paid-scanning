# 收费软件检测系统 - 系统架构文档
## System Architecture Document

---

## 1. 架构概述

### 1.1 架构原则
- **微服务架构**：服务解耦，独立部署和扩展
- **云原生设计**：容器化部署，支持弹性伸缩
- **安全优先**：端到端加密，零信任架构
- **高可用性**：多区域部署，故障自动恢复
- **可观测性**：全链路监控，实时告警

### 1.2 架构特点
- 🔄 **异步处理**：扫描任务异步执行，提升用户体验
- 🚀 **高性能**：分布式扫描，支持大规模并发
- 🛡️ **安全性**：多层安全防护，数据加密存储
- 📊 **可扩展**：水平扩展，支持百万级用户
- 🔍 **智能化**：机器学习驱动的风险评估

---

## 2. 系统整体架构

### 2.1 分层架构
```
┌─────────────────────────────────────────────────────────────┐
│                        客户端层                              │
├─────────────────┬─────────────────┬─────────────────────────┤
│   桌面客户端     │   Web管理后台    │      移动端App          │
│  (Electron)     │   (React)       │   (React Native)       │
└─────────────────┴─────────────────┴─────────────────────────┘
                           │
┌─────────────────────────────────────────────────────────────┐
│                      网关层                                  │
├─────────────────────────────────────────────────────────────┤
│  API Gateway (Kong/Envoy) + Load Balancer (Nginx)          │
│  • 请求路由    • 负载均衡    • 限流熔断    • 安全认证        │
└─────────────────────────────────────────────────────────────┘
                           │
┌─────────────────────────────────────────────────────────────┐
│                      服务层                                  │
├──────────┬──────────┬──────────┬──────────┬─────────────────┤
│用户认证服务│扫描引擎服务│风险评估服务│数据分析服务│    通知服务     │
│(Auth)    │(Scanner) │(Risk)    │(Analytics)│ (Notification) │
└──────────┴──────────┴──────────┴──────────┴─────────────────┘
                           │
┌─────────────────────────────────────────────────────────────┐
│                      数据层                                  │
├──────────┬──────────┬──────────┬──────────┬─────────────────┤
│ 主数据库  │  缓存层   │  搜索引擎 │  文件存储 │    消息队列     │
│PostgreSQL│  Redis   │Elasticsearch│ MinIO  │   RabbitMQ     │
└──────────┴──────────┴──────────┴──────────┴─────────────────┘
```

### 2.2 部署架构
```
┌─────────────────────────────────────────────────────────────┐
│                       CDN层                                 │
│  CloudFlare / AWS CloudFront - 静态资源加速                 │
└─────────────────────────────────────────────────────────────┘
                           │
┌─────────────────────────────────────────────────────────────┐
│                    负载均衡层                                │
│  AWS ALB / 阿里云SLB - 流量分发和SSL终结                     │
└─────────────────────────────────────────────────────────────┘
                           │
┌─────────────────────────────────────────────────────────────┐
│                  Kubernetes集群                             │
├─────────────────┬─────────────────┬─────────────────────────┤
│    生产环境      │    预发环境      │       开发环境          │
│  (Production)   │   (Staging)     │    (Development)       │
│  多可用区部署    │   单可用区       │      本地部署           │
└─────────────────┴─────────────────┴─────────────────────────┘
```

---

## 3. 微服务架构设计

### 3.1 服务拆分策略

#### 3.1.1 用户认证服务 (Auth Service)
**职责**：
- 用户注册、登录、注销
- JWT Token管理
- 权限控制和RBAC
- 第三方登录集成

**技术栈**：
- 语言：Golang
- 框架：Gin
- 数据库：PostgreSQL (GORM)
- 缓存：Redis (go-redis)

**API接口**：
```yaml
POST /auth/register     # 用户注册
POST /auth/login        # 用户登录
POST /auth/refresh      # Token刷新
DELETE /auth/logout     # 用户注销
GET /auth/profile       # 获取用户信息
```

#### 3.1.2 扫描引擎服务 (Scanner Service)
**职责**：
- 软件检测和识别
- 文件系统扫描
- 进程监控
- 网络行为分析

**技术栈**：
- 语言：Golang
- 框架：Gin
- 任务队列：Asynq + Redis
- 检测引擎：自研 + 开源工具
- ORM：GORM

**核心模块**：
```go
// 扫描引擎架构
type ScannerEngine struct {
    fileScanner     *FileScanner     // 文件扫描器
    registryScanner *RegistryScanner // 注册表扫描器
    processMonitor  *ProcessMonitor  // 进程监控器
    networkAnalyzer *NetworkAnalyzer // 网络分析器
    logger          *logrus.Logger
}

func NewScannerEngine() *ScannerEngine {
    return &ScannerEngine{
        fileScanner:     NewFileScanner(),
        registryScanner: NewRegistryScanner(),
        processMonitor:  NewProcessMonitor(),
        networkAnalyzer: NewNetworkAnalyzer(),
        logger:          logrus.New(),
    }
}

func (s *ScannerEngine) ScanSystem(ctx context.Context, config *ScanConfig) (*ScanResult, error) {
    // 系统扫描主流程
    var wg sync.WaitGroup
    results := make(chan interface{}, 4)
    errors := make(chan error, 4)
    
    // 并发执行各种扫描
    wg.Add(4)
    go s.runFileScanner(ctx, &wg, config.Paths, results, errors)
    go s.runRegistryScanner(ctx, &wg, results, errors)
    go s.runProcessMonitor(ctx, &wg, results, errors)
    go s.runNetworkAnalyzer(ctx, &wg, results, errors)
    
    wg.Wait()
    close(results)
    close(errors)
    
    return s.aggregateResults(results, errors)
}
```

#### 3.1.3 风险评估服务 (Risk Assessment Service)
**职责**：
- 软件风险评分
- 许可证分析
- 行为模式识别
- 机器学习模型推理

**技术栈**：
- 语言：Golang
- 框架：Gin
- ML推理：TensorFlow Serving (gRPC调用)
- 特征存储：Redis
- 数据处理：GoNum

**风险评估模型**：
```go
type RiskAssessmentModel struct {
    licenseAnalyzer  *LicenseAnalyzer
    behaviorAnalyzer *BehaviorAnalyzer
    mlClient         *tensorflow.ServingClient
    ruleEngine       *RuleEngine
    logger           *logrus.Logger
}

func NewRiskAssessmentModel() *RiskAssessmentModel {
    return &RiskAssessmentModel{
        licenseAnalyzer:  NewLicenseAnalyzer(),
        behaviorAnalyzer: NewBehaviorAnalyzer(),
        mlClient:         tensorflow.NewServingClient("localhost:8500"),
        ruleEngine:       NewRuleEngine(),
        logger:           logrus.New(),
    }
}

type RiskAssessmentResult struct {
    RiskScore int      `json:"risk_score"`
    RiskLevel string   `json:"risk_level"`
    Reasons   []string `json:"reasons"`
}

func (r *RiskAssessmentModel) AssessRisk(ctx context.Context, softwareInfo *SoftwareInfo) (*RiskAssessmentResult, error) {
    // 特征提取
    features, err := r.extractFeatures(softwareInfo)
    if err != nil {
        return nil, fmt.Errorf("feature extraction failed: %w", err)
    }
    
    // 规则引擎评估
    ruleScore := r.ruleEngine.Assess(features)
    
    // ML模型评估
    mlScore, err := r.callMLModel(ctx, features)
    if err != nil {
        r.logger.Warnf("ML model call failed, using rule-based score: %v", err)
        mlScore = ruleScore
    }
    
    // 综合评分
    finalScore := r.combineScores(ruleScore, mlScore)
    
    return &RiskAssessmentResult{
        RiskScore: finalScore,
        RiskLevel: r.getRiskLevel(finalScore),
        Reasons:   r.explainRisk(features),
    }, nil
}
```

#### 3.1.4 数据分析服务 (Analytics Service)
**职责**：
- 用户行为分析
- 风险趋势分析
- 报告生成
- 数据可视化

**技术栈**：
- 语言：Golang
- 框架：Gin
- 数据处理：GoNum + Gota
- 图表生成：Chart.js (前端) + API数据

#### 3.1.5 通知服务 (Notification Service)
**职责**：
- 实时通知推送
- 邮件发送
- 短信发送
- Webhook回调

**技术栈**：
- 语言：Golang
- 消息队列：RabbitMQ (amqp091-go)
- 邮件：SMTP (gomail)
- 短信：阿里云/腾讯云 SDK
- WebSocket：gorilla/websocket

### 3.2 服务间通信

#### 3.2.1 同步通信
- **HTTP/REST**：用于实时查询和操作
- **gRPC**：用于高性能内部服务调用
- **GraphQL**：用于复杂数据查询

#### 3.2.2 异步通信
- **消息队列**：RabbitMQ处理异步任务
- **事件总线**：Apache Kafka处理事件流
- **发布订阅**：Redis Pub/Sub处理实时通知

```yaml
# 消息队列设计
queues:
  scan_tasks:           # 扫描任务队列
    exchange: scan.direct
    routing_key: scan.start
    
  risk_assessment:      # 风险评估队列
    exchange: risk.topic
    routing_key: risk.assess
    
  notifications:        # 通知队列
    exchange: notify.fanout
    routing_key: notify.send
```

---

## 4. 数据架构设计

### 4.1 数据库设计

#### 4.1.1 主数据库 (PostgreSQL)
```sql
-- 用户表
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(20) DEFAULT 'user',
    subscription_type VARCHAR(20) DEFAULT 'free',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 软件信息表
CREATE TABLE software_database (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    vendor VARCHAR(255),
    version VARCHAR(100),
    license_type VARCHAR(100),
    commercial_use_allowed BOOLEAN,
    individual_use_free BOOLEAN,
    risk_level INTEGER CHECK (risk_level >= 0 AND risk_level <= 100),
    last_policy_change DATE,
    data_collection BOOLEAN DEFAULT FALSE,
    network_activity_level INTEGER DEFAULT 0,
    fingerprint_hash VARCHAR(64),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 用户设备表
CREATE TABLE user_devices (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    device_name VARCHAR(255) NOT NULL,
    device_type VARCHAR(50), -- desktop, laptop, server
    os_type VARCHAR(50),     -- windows, macos, linux
    os_version VARCHAR(100),
    agent_version VARCHAR(50),
    last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE
);

-- 扫描记录表
CREATE TABLE scan_results (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    device_id INTEGER REFERENCES user_devices(id),
    software_id INTEGER REFERENCES software_database(id),
    detected_version VARCHAR(100),
    installation_path TEXT,
    file_size BIGINT,
    install_date DATE,
    last_used DATE,
    usage_frequency INTEGER DEFAULT 0,
    risk_score INTEGER,
    scan_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(50) DEFAULT 'active' -- active, removed, updated, ignored
);

-- 风险评估历史表
CREATE TABLE risk_assessments (
    id SERIAL PRIMARY KEY,
    software_id INTEGER REFERENCES software_database(id),
    assessment_version VARCHAR(20),
    risk_score INTEGER,
    risk_factors JSONB,
    model_version VARCHAR(20),
    assessed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 用户订阅表
CREATE TABLE subscriptions (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    plan_type VARCHAR(50), -- free, professional, enterprise
    start_date DATE NOT NULL,
    end_date DATE,
    status VARCHAR(20) DEFAULT 'active', -- active, expired, cancelled
    payment_info JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 4.1.2 索引设计
```sql
-- 性能优化索引
CREATE INDEX idx_scan_results_user_device ON scan_results(user_id, device_id);
CREATE INDEX idx_scan_results_risk_score ON scan_results(risk_score DESC);
CREATE INDEX idx_software_risk_level ON software_database(risk_level DESC);
CREATE INDEX idx_software_name_version ON software_database(name, version);
CREATE INDEX idx_scan_results_scan_date ON scan_results(scan_date DESC);

-- 全文搜索索引
CREATE INDEX idx_software_search ON software_database USING gin(to_tsvector('english', name || ' ' || vendor));
```

### 4.2 缓存架构 (Redis)

#### 4.2.1 缓存策略
```yaml
# Redis集群配置
redis_clusters:
  session_cache:      # 会话缓存
    purpose: "用户会话和JWT Token"
    ttl: 7200          # 2小时
    
  software_cache:     # 软件信息缓存
    purpose: "热点软件信息"
    ttl: 86400         # 24小时
    
  scan_cache:        # 扫描结果缓存
    purpose: "最近扫描结果"
    ttl: 3600          # 1小时
    
  risk_cache:        # 风险评估缓存
    purpose: "风险评估结果"
    ttl: 21600         # 6小时
```

#### 4.2.2 缓存模式
```python
# Go缓存管理器实现
package cache

import (
    "context"
    "encoding/json"
    "fmt"
    "time"
    "crypto/sha256"
    
    "github.com/go-redis/redis/v8"
)

type CacheManager struct {
    client *redis.Client
    logger *logrus.Logger
}

func NewCacheManager(redisURL string) *CacheManager {
    rdb := redis.NewClient(&redis.Options{
        Addr: redisURL,
    })
    
    return &CacheManager{
        client: rdb,
        logger: logrus.New(),
    }
}

func (c *CacheManager) generateKey(prefix, funcName string, args interface{}) string {
    argsBytes, _ := json.Marshal(args)
    hash := sha256.Sum256(argsBytes)
    return fmt.Sprintf("%s:%s:%x", prefix, funcName, hash)
}

func (c *CacheManager) Get(ctx context.Context, key string, dest interface{}) error {
    val, err := c.client.Get(ctx, key).Result()
    if err != nil {
        return err
    }
    
    return json.Unmarshal([]byte(val), dest)
}

func (c *CacheManager) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error {
    bytes, err := json.Marshal(value)
    if err != nil {
        return err
    }
    
    return c.client.Set(ctx, key, bytes, ttl).Err()
}

// 使用示例
func GetSoftwareInfo(ctx context.Context, softwareID int) (*SoftwareInfo, error) {
    cacheKey := fmt.Sprintf("software:%d", softwareID)
    
    var software SoftwareInfo
    err := cacheManager.Get(ctx, cacheKey, &software)
    if err == nil {
        return &software, nil
    }
    
    // 缓存未命中，从数据库获取
    software, err = database.FetchSoftware(ctx, softwareID)
    if err != nil {
        return nil, err
    }
    
    // 缓存结果
    cacheManager.Set(ctx, cacheKey, software, time.Hour)
    
    return &software, nil
}
```

### 4.3 搜索引擎 (Elasticsearch)

#### 4.3.1 索引设计
```json
{
  "software_index": {
    "mappings": {
      "properties": {
        "name": {
          "type": "text",
          "analyzer": "standard",
          "fields": {
            "keyword": {
              "type": "keyword"
            }
          }
        },
        "vendor": {
          "type": "text",
          "analyzer": "standard"
        },
        "description": {
          "type": "text",
          "analyzer": "english"
        },
        "risk_level": {
          "type": "integer"
        },
        "license_type": {
          "type": "keyword"
        },
        "tags": {
          "type": "keyword"
        },
        "created_at": {
          "type": "date"
        }
      }
    }
  }
}
```

---

## 5. 安全架构

### 5.1 安全层次

#### 5.1.1 网络安全
- **WAF防护**：Web应用防火墙，防止SQL注入、XSS等攻击
- **DDoS防护**：分布式拒绝服务攻击防护
- **IP白名单**：关键API的IP访问控制
- **SSL/TLS**：全站HTTPS加密传输

#### 5.1.2 应用安全
```python
# Go JWT Token安全配置
package config

import (
    "time"
    "github.com/golang-jwt/jwt/v4"
)

type JWTConfig struct {
    Algorithm           string        `yaml:"algorithm"`
    AccessTokenExpire   time.Duration `yaml:"access_token_expire"`
    RefreshTokenExpire  time.Duration `yaml:"refresh_token_expire"`
    Issuer              string        `yaml:"issuer"`
    Audience            string        `yaml:"audience"`
    PrivateKeyPath      string        `yaml:"private_key_path"`
    PublicKeyPath       string        `yaml:"public_key_path"`
}

var DefaultJWTConfig = JWTConfig{
    Algorithm:          "RS256",
    AccessTokenExpire:  time.Hour,
    RefreshTokenExpire: 7 * 24 * time.Hour,
    Issuer:            "saas-scanning-system",
    Audience:          "saas-scanning-users",
}

// 密码安全策略
type PasswordPolicy struct {
    MinLength           int  `yaml:"min_length"`
    RequireUppercase    bool `yaml:"require_uppercase"`
    RequireLowercase    bool `yaml:"require_lowercase"`
    RequireNumbers      bool `yaml:"require_numbers"`
    RequireSpecialChars bool `yaml:"require_special_chars"`
    SaltRounds          int  `yaml:"salt_rounds"`
}

var DefaultPasswordPolicy = PasswordPolicy{
    MinLength:           8,
    RequireUppercase:    true,
    RequireLowercase:    true,
    RequireNumbers:      true,
    RequireSpecialChars: true,
    SaltRounds:          12,
}

// API限流配置
type RateLimitConfig struct {
    Default string `yaml:"default"`
    Auth    string `yaml:"auth"`
    Scan    string `yaml:"scan"`
    Upload  string `yaml:"upload"`
}

var DefaultRateLimitConfig = RateLimitConfig{
    Default: "100/minute",
    Auth:    "10/minute",
    Scan:    "5/minute",
    Upload:  "3/minute",
}
```

#### 5.1.3 数据安全
```sql
-- 敏感数据加密
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 用户敏感信息加密存储
CREATE TABLE user_sensitive_data (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    encrypted_data TEXT, -- 使用AES-256加密
    data_type VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 审计日志表
CREATE TABLE audit_logs (
    id SERIAL PRIMARY KEY,
    user_id INTEGER,
    action VARCHAR(100) NOT NULL,
    resource_type VARCHAR(50),
    resource_id INTEGER,
    ip_address INET,
    user_agent TEXT,
    details JSONB,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 5.2 权限控制 (RBAC)

#### 5.2.1 角色定义
```yaml
roles:
  admin:
    permissions:
      - user.manage
      - system.config
      - data.export
      - audit.view
      
  enterprise_admin:
    permissions:
      - team.manage
      - device.manage
      - report.generate
      - policy.config
      
  professional_user:
    permissions:
      - scan.unlimited
      - report.advanced
      - alert.config
      
  free_user:
    permissions:
      - scan.basic
      - report.basic
```

#### 5.2.2 权限中间件
```python
// Go权限中间件
package middleware

import (
    "net/http"
    "strings"
    
    "github.com/gin-gonic/gin"
    "github.com/golang-jwt/jwt/v4"
)

type AuthMiddleware struct {
    jwtSecret []byte
    logger    *logrus.Logger
}

func NewAuthMiddleware(jwtSecret []byte) *AuthMiddleware {
    return &AuthMiddleware{
        jwtSecret: jwtSecret,
        logger:    logrus.New(),
    }
}

func (a *AuthMiddleware) RequirePermission(permission string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 从Header获取Token
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing authorization token"})
            c.Abort()
            return
        }
        
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        
        // 验证JWT Token
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
            return a.jwtSecret, nil
        })
        
        if err != nil || !token.Valid {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
            c.Abort()
            return
        }
        
        // 获取用户信息
        claims, ok := token.Claims.(jwt.MapClaims)
        if !ok {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token claims"})
            c.Abort()
            return
        }
        
        userID := claims["user_id"].(string)
        user, err := getUserByID(userID)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
            c.Abort()
            return
        }
        
        // 检查权限
        if !user.HasPermission(permission) {
            c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
            c.Abort()
            return
        }
        
        // 将用户信息存储到上下文
        c.Set("user", user)
        c.Next()
    }
}

// 使用示例
func SetupRoutes(r *gin.Engine, authMiddleware *AuthMiddleware) {
    api := r.Group("/api")
    
    // 需要权限的路由
    admin := api.Group("/admin")
    admin.Use(authMiddleware.RequirePermission("user.manage"))
    {
        admin.GET("/users", handleGetUsers)
        admin.POST("/users", handleCreateUser)
    }
}
```

---

## 6. 性能架构

### 6.1 扩展策略

#### 6.1.1 水平扩展
```yaml
# Kubernetes HPA配置
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: scanner-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: scanner-service
  minReplicas: 3
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

#### 6.1.2 数据库优化
```sql
-- 分区表设计（按时间分区）
CREATE TABLE scan_results_y2024m01 PARTITION OF scan_results
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE scan_results_y2024m02 PARTITION OF scan_results
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

-- 读写分离配置
-- 主库：写操作
-- 从库：读操作
CREATE PUBLICATION scan_results_pub FOR TABLE scan_results;
```

### 6.2 性能监控

#### 6.2.1 APM配置
```python
# Go应用性能监控
package monitoring

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/jaeger"
    "go.opentelemetry.io/otel/sdk/trace"
)

// Prometheus指标定义
var (
    RequestCount = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total HTTP requests",
        },
        []string{"method", "endpoint", "status"},
    )
    
    RequestLatency = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "http_request_duration_seconds",
            Help: "HTTP request latency",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "endpoint"},
    )
    
    ActiveScans = promauto.NewGauge(
        prometheus.GaugeOpts{
            Name: "active_scans_total",
            Help: "Number of active scans",
        },
    )
    
    DatabaseConnections = promauto.NewGauge(
        prometheus.GaugeOpts{
            Name: "database_connections_active",
            Help: "Number of active database connections",
        },
    )
)

// 初始化链路追踪
func InitTracing(serviceName string) error {
    exporter, err := jaeger.New(jaeger.WithCollectorEndpoint(
        jaeger.WithEndpoint("http://jaeger-collector:14268/api/traces"),
    ))
    if err != nil {
        return err
    }
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
        trace.WithResource(resource.NewWithAttributes(
            semconv.SchemaURL,
            semconv.ServiceNameKey.String(serviceName),
        )),
    )
    
    otel.SetTracerProvider(tp)
    return nil
}

// 中间件示例
func PrometheusMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        
        c.Next()
        
        duration := time.Since(start).Seconds()
        status := strconv.Itoa(c.Writer.Status())
        
        RequestCount.WithLabelValues(c.Request.Method, c.FullPath(), status).Inc()
        RequestLatency.WithLabelValues(c.Request.Method, c.FullPath()).Observe(duration)
    }
}
```

---

## 7. 监控和运维

### 7.1 监控体系

#### 7.1.1 监控指标
```yaml
# Prometheus监控配置
monitoring:
  application_metrics:
    - request_rate: "请求速率"
    - error_rate: "错误率"
    - response_time: "响应时间"
    - active_users: "活跃用户数"
    
  infrastructure_metrics:
    - cpu_usage: "CPU使用率"
    - memory_usage: "内存使用率"
    - disk_usage: "磁盘使用率"
    - network_io: "网络IO"
    
  business_metrics:
    - scan_completion_rate: "扫描完成率"
    - risk_detection_accuracy: "风险检测准确率"
    - user_satisfaction: "用户满意度"
```

#### 7.1.2 告警规则
```yaml
# Alertmanager告警规则
groups:
- name: application
  rules:
  - alert: HighErrorRate
    expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
    for: 5m
    labels:
      severity: critical
    annotations:
      summary: "High error rate detected"
      
  - alert: ScanServiceDown
    expr: up{job="scanner-service"} == 0
    for: 1m
    labels:
      severity: critical
    annotations:
      summary: "Scanner service is down"
```

### 7.2 日志架构

#### 7.2.1 日志收集
```yaml
# ELK Stack配置
logging:
  filebeat:
    inputs:
      - type: container
        paths:
          - /var/log/containers/*.log
        processors:
          - add_kubernetes_metadata:
              host: ${NODE_NAME}
              
  logstash:
    pipeline:
      - input: beats
      - filter: 
          - grok
          - mutate
          - date
      - output: elasticsearch
      
  elasticsearch:
    cluster_name: "saas-scanning-logs"
    indices:
      - name: "application-logs"
      - name: "audit-logs"
      - name: "security-logs"
```

#### 7.2.2 日志格式
```json
{
  "timestamp": "2024-12-19T10:30:00Z",
  "level": "INFO",
  "service": "scanner-service",
  "trace_id": "abc123def456",
  "span_id": "789ghi012jkl",
  "user_id": "user_12345",
  "action": "scan_started",
  "resource": {
    "type": "device",
    "id": "device_67890"
  },
  "metadata": {
    "ip_address": "192.168.1.100",
    "user_agent": "ScannerAgent/1.0"
  },
  "message": "System scan started for device device_67890"
}
```

---

## 8. 部署架构

### 8.1 容器化部署

#### 8.1.1 Docker配置
```dockerfile
# 扫描服务Dockerfile (多阶段构建)
FROM golang:1.21-alpine AS builder

WORKDIR /app

# 安装系统依赖
RUN apk add --no-cache git ca-certificates tzdata

# 复制go mod文件
COPY go.mod go.sum ./
RUN go mod download

# 复制源代码
COPY . .

# 编译应用
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o scanner-service ./cmd/scanner

# 运行阶段
FROM alpine:latest

RUN apk --no-cache add ca-certificates tzdata
WORKDIR /root/

# 从构建阶段复制二进制文件
COPY --from=builder /app/scanner-service .
COPY --from=builder /app/configs ./configs

# 创建非root用户
RUN addgroup -g 1001 -S appuser && \
    adduser -u 1001 -S appuser -G appuser

USER appuser

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

EXPOSE 8080

# 启动应用
CMD ["./scanner-service"]
```

#### 8.1.2 Kubernetes部署
```yaml
# scanner-service部署配置
apiVersion: apps/v1
kind: Deployment
metadata:
  name: scanner-service
  labels:
    app: scanner-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: scanner-service
  template:
    metadata:
      labels:
        app: scanner-service
    spec:
      containers:
      - name: scanner-service
        image: saas-scanning/scanner-service:v1.0.0
        ports:
        - containerPort: 8080
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-secret
              key: url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: scanner-service
spec:
  selector:
    app: scanner-service
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
  type: ClusterIP
```

### 8.2 CI/CD流水线

#### 8.2.1 GitLab CI配置
```yaml
# .gitlab-ci.yml
stages:
  - test
  - build
  - deploy

variables:
  DOCKER_REGISTRY: registry.gitlab.com/saas-scanning
  KUBERNETES_NAMESPACE: saas-scanning

test:
  stage: test
  image: golang:1.21-alpine
  script:
    - go mod download
    - go test -v -race -coverprofile=coverage.out ./...
    - go tool cover -html=coverage.out -o coverage.html
    - go vet ./...
    - golangci-lint run
  coverage: '/coverage: \d+\.\d+% of statements/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml

build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker build -t $DOCKER_REGISTRY/scanner-service:$CI_COMMIT_SHA .
    - docker push $DOCKER_REGISTRY/scanner-service:$CI_COMMIT_SHA
  only:
    - main
    - develop

deploy:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    - kubectl set image deployment/scanner-service scanner-service=$DOCKER_REGISTRY/scanner-service:$CI_COMMIT_SHA
    - kubectl rollout status deployment/scanner-service
  only:
    - main
  environment:
    name: production
```

---

## 9. 灾备和高可用

### 9.1 高可用设计

#### 9.1.1 多区域部署
```yaml
# 多区域部署配置
regions:
  primary:
    name: "us-east-1"
    services: ["all"]
    database: "master"
    
  secondary:
    name: "us-west-2"  
    services: ["read-only"]
    database: "replica"
    
  disaster_recovery:
    name: "eu-west-1"
    services: ["minimal"]
    database: "backup"
```

#### 9.1.2 故障转移
```python
# 自动故障转移逻辑
class FailoverManager:
    def __init__(self):
        self.health_checker = HealthChecker()
        self.load_balancer = LoadBalancer()
        
    async def monitor_services(self):
        while True:
            for service in self.services:
                if not await self.health_checker.is_healthy(service):
                    await self.failover_service(service)
            await asyncio.sleep(30)
    
    async def failover_service(self, failed_service):
        # 从负载均衡器移除失败的服务
        await self.load_balancer.remove_service(failed_service)
        
        # 启动备用服务
        backup_service = await self.start_backup_service(failed_service)
        
        # 添加到负载均衡器
        await self.load_balancer.add_service(backup_service)
        
        # 发送告警
        await self.send_alert(f"Service {failed_service} failed over to {backup_service}")
```

### 9.2 数据备份

#### 9.2.1 数据库备份策略
```bash
#!/bin/bash
# 数据库备份脚本

# 全量备份（每天执行）
pg_dump -h $DB_HOST -U $DB_USER -d $DB_NAME > backup_$(date +%Y%m%d).sql

# 增量备份（每小时执行）
pg_receivewal -h $DB_HOST -U $DB_USER -D /backup/wal

# 上传到云存储
aws s3 cp backup_$(date +%Y%m%d).sql s3://saas-scanning-backups/database/

# 清理旧备份（保留30天）
find /backup -name "backup_*.sql" -mtime +30 -delete
```

---

## 10. 架构演进规划

### 10.1 短期优化 (3-6个月)
- **性能优化**：数据库查询优化，缓存命中率提升
- **监控完善**：补充业务监控指标，完善告警规则
- **安全加固**：加强API安全防护，完善审计日志
- **用户体验**：优化扫描速度，减少资源占用

### 10.2 中期扩展 (6-12个月)
- **智能化升级**：引入更先进的机器学习模型
- **多云部署**：支持AWS、Azure、阿里云等多云环境
- **边缘计算**：部署边缘节点，减少网络延迟
- **API生态**：开放API平台，支持第三方集成

### 10.3 长期规划 (1-2年)
- **全球化部署**：支持多语言、多地区合规要求
- **AI驱动**：全面AI化的风险预测和处理建议
- **生态建设**：构建开发者社区和合作伙伴生态
- **行业扩展**：扩展到更多行业的合规检测需求

---

## 11. 技术债务管理

### 11.1 代码质量
- **代码规范**：统一代码风格，强制代码审查
- **测试覆盖**：单元测试覆盖率 > 80%，集成测试覆盖核心流程
- **文档维护**：API文档自动生成，架构文档定期更新
- **重构计划**：定期重构老旧代码，优化架构设计

### 11.2 技术选型
- **技术栈统一**：避免技术栈过于分散，统一开发语言
- **依赖管理**：定期更新依赖版本，修复安全漏洞
- **性能基准**：建立性能基准测试，持续性能优化
- **可维护性**：优先考虑可维护性，避免过度设计

---

*文档版本：v1.0*  
*创建时间：2024年12月*  
*维护团队：架构组*
